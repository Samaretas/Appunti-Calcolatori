\documentclass[class=book, crop=false, oneside]{standalone}
\usepackage[subpreambles=true]{standalone}

\usepackage{../../style}

\graphicspath{{./assets/images/}}
\newmintinline{asm}{}

% arara: pdflatex: { synctex: yes, shell: yes }
% arara: latexmk: { clean: partial }
\begin{document}

\chapter{Esempi e confronti di programmi Assembly}\label{ch:asm}
Ora andiamo a riprendere alcuni esempi già portati nel capitolo dedicato all'Assembly MIPS e andremo a confrontare le implementazioni proposte con le corrispettive per Assembly x86 e ARM.

Per completezza, specifichiamo che il codice che mostreremo è stato ottenuto con il compilatore \mintinline{batch}{gcc}, lievemente modificato affinché risulti più leggibile (principalmente sull'ordine logico delle istruzioni e sulla nomenclatura dei registri).

\section{Semplici espressioni aritmetico-logiche}
Cominciamo con delle semplici operazioni aritmetiche, che evidenzieranno come le architetture RISC (MIPS e ARM) permettono di eseguire questo tipo di istruzioni in modo molto naturale, al contrario dell'implementazione leggermente più macchinosa di x86.\\
L'espressione è la seguente:
\begin{minted}{c}
f = (g + h) - (i + j);
\end{minted}

\subsubsection{Implementazione MIPS}
In MIPS assumiamo che le variabili \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} vengano mappate nei 4 registri dedicati agli argomenti, rispettivamente \register{\$a0}, \register{\$a1}, \register{\$a2} e \register{\$a3}, e decidiamo di salvare il risultato in \register{\$v0}. A questo punto la conversione Assembly è immediata:
\begin{minted}{asm}
add $a0, $a0, $a1  # memorizza in $a0 g + h
add $v0, $a2, $a3  # memorizza in $v0 i + j
sub $v0, $a0, $v0  # memorizza in $v0 (g + h) - (i + j)
\end{minted}

\subsubsection{Implementazione x86}
Siano \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} mappate rispettivamente in \register{\%rdi}, \register{\%rsi}, \register{\%rcx} e \register{\%rdx} e si voglia salvare il risultato in \register{\%rax}.\\
Il problema di x86 sta nel fatto che le operazioni sono solo a due operandi, con il secondo che funge da destinazione, e quindi non è possibile specificare un diverso registro di destinazione.\\
Possiamo aggirare questa limitazione sfruttando l'istruzione \mintinline{gas}{lea}: questa infatti ha come argomenti \texttt{<addr>, <dst>} e calcola l'indirizzo \texttt{<addr>} secondo base, spiazzamento e indice shiftato, e salva tutto in \texttt{<dst>}. Sarà quindi sufficiente impostare spiazzamento e shift a 0 per riuscire a sommare agevolmente base (per noi \register{\%rdi}) a indice non shiftato (\register{\%rsi}) e salvarne il risultato in \register{\%rax}.
\begin{minted}{gas}
leaq (%rdi, %rsi), %rax  # %rax = g + h con il trick visto sopra
addq %rcx, %rdx          # %rdx = i + j
subq %rdx, %rax          # %rax = (g + h) - (i + j)
\end{minted}

\subsubsection{Implementazione ARM}
Analogamente a MIPS, anche l'implementazione ARM è molto semplice e naturale, una volta mappate \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} in \register{r0}, \register{r1}, \register{r2} e \register{r3} e decidendo di salvare il tutto in \register{r0}.\\
Qui vengono usate \mintinline{asm}{adds} e \mintinline{asm}{subs}, che aggiornano i flag, ma usare le normalissime \mintinline{asm}{add} e \mintinline{asm}{sub} non avrebbe cambiato nulla.
\begin{minted}{arm}
adds r1, r0, r1  ; r1 = g + h
adds r3, r2, r3  ; r3 = i + j
subs r0, r1, r3  ; r0 = (g + h) - (i + j)
\end{minted}

\section{Array e accesso alla memoria}
Ora invece prenderemo come esempio una semplice istruzione che agisce su un array per mostrare diverse modalità di accesso alla memoria: questa volta, x86 permetterà di ridurre notevolmente il numero di righe di codice, mentre le due ISA RISC richiederanno molte più istruzioni.
\begin{minted}{c}
a[12] = h + a[8];
\end{minted}
\subsubsection{Implementazione MIPS}
Come visto in 6.3, in MIPS sarà necessario utilizzare le istruzioni di \mintinline{asm}{lw} e \mintinline{asm}{sw} per accedere all'indirizzo dell'array; inoltre, ricordiamo che  lo shift necessario a ottenere l'indirizzo desiderato andrà sempre moltiplicato per lo spiazzamento di 4 byte, sicché ogni parola risulti lunga 32 bit.\\
Assumendo quindi che \mintinline{c}{h} stia in \register{\$a0} e l'indirizzo dell'array \mintinline{c}{a} in \register{\$a1} otteniamo:
\begin{minted}{asm}
lw $v0, 32($a1)    # carica in $v0 il contenuto di a shiftato di 4 * 8
add $a0, $v0, $a0  # salva in $a0 a[8] + h
sw $a0, 48($a1)    # riponi il contenuto di $a0 nell'indirizzo di a shiftato di 4 * 12
\end{minted}

\subsubsection{Implementazione x86}
La capacità di accedere direttamente alla memoria grazie a istruzioni come \mintinline{gas}{addl} e \mintinline{gas}{movl} semplifica di molto questa operazione per l'ISA Intel.\\
Assumendo che  \mintinline{c}{h} stia \register{\%edi} e l'indirizzo di \mintinline{c}{a} in \register{\%rsi},otteniamo:
\begin{minted}{gas}
addl 32(%rsi), %edi  # %edi = a[8] + h
movl %edi, 48(%rsi)  # sposta a[8] + h in a[12]
\end{minted}

\subsubsection{Implementazione ARM}
La versione ARM è molto simile a quella MIPS.\\
Assumendo che \mintinline{c}{h} stia in \register{r0} e l'indirizzo di \mintinline{c}{a} in \register{r1}, otteniamo:
\begin{minted}{arm}
ldr r3, [r1, #32]  ; carica a[8] in r3
add r0, r3, r0     ; salva in r0 a[8] + h
str r0, [r1, #48]  ; riponi r0 in a[12]
\end{minted}


\section{Blocchi condizionali}
Vediamo ora la gestione di istruzioni condizionali. Solitamente queste vengono gestite da istruzioni di salti condizionati, ma alcune ISA hanno modalità di gestione decisamente peculiari.
\subsection*{Condizioni di uguaglianza}
Andiamo ad analizzare le traduzioni del segente codice C:
\begin{minted}[linenos, breaklines, tabsize = 4]{c}
if (i == j){
	f = g + h;
} else {
	f = g - h;
}
\end{minted}
\subsubsection{Implementazione MIPS}
In MIPS assumiamo che le variabili \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} vengano mappate nei 4 registri dedicati agli argomenti, rispettivamente \register{\$a0}, \register{\$a1}, \register{\$a2} e \register{\$a3}, e decidiamo di salvare il risultato in \register{\$v0}.\\
Utilizzeremo quindi \mintinline{asm}{bne} per operare un confronto fra due registri general purpose per verificare \mintinline{c}{i == j}; qualora la condizione non fosse verificata, faremo il salto a L2 e alla sottrazione \mintinline{c}{g -h}. Differentemente, verrà eseguita la somma \mintinline{c}{g + h} e un salto incondizionato \mintinline{asm}{j} farà terminare la sequenza.
\begin{minted}[linenos, tabsize = 4]{asm}
  bne $a2, $a3, L2   # salta a L2 se $a2 e $a3 sono diversi
  add $v0, $a0, $a1
  j L3   # salta a L3
L2:
  sub $v0, $a0, $a1
L3:
\end{minted}

\subsubsection{Implementazione x86}
Siano \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} mappate rispettivamente in \register{\%rdi}, \register{\%rsi}, \register{\%rcx} e \register{\%rdx} e si voglia salvare il risultato \mintinline{c}{f} in \register{\%rax}.\\
L'implementazione risulta più complessa rispetto a quella di MIPS, poiché dovremo usare \mintinline{gas}{lea} al posto di \mintinline{gas}{add} e sopratto dovremo affiancare alla \mintinline{gas}{sub} una \mintinline{gas}{mov} per far sì che il risultato vada salvato in \register{\%rax}. Inoltre, è necessaria una \mintinline{gas}{cmpq} per settare i flag e solo dopo possiamo lanciare l'istruzione di salto.
\begin{minted}[linenos, tabsize = 4]{gas}
  cmpq %rcx, %rdx  # confronta i e j e setta il flag
  jne L2   # se i != j, salta a L2
  leaq (%rdi, %rsi), %rax  # salva in %rax g + h
  jmp L3
L2:
  movq %rdi, %rax  # sposta g da %rdi a %rax
  subq %rsi, %rax  # salva in %rax
L3:
\end{minted}
Tutto questo può però essere semplificato dalla magica istruzione \mintinline{gas}{cmov} (\mintinline{gas}{mov} condizionale) di x86:
\begin{minted}[linenos, tabsize = 4]{gas}
leaq (%rdi, %rsi), %rax  # salva g + h in %rax
subq %rdi, %rsi  # salva g - h in %rsi
cmpq %rcx, %rdx  # i == j
cmovne %rsi, %rax  # sposta %rsi in %rax se il i è diverso da j
\end{minted}

\subsubsection{Implementazione ARM}
L'implementazione ARM ci permette di evitare istruzioni di salto grazie alla sua versione condizionale delle operazioni aritmetiche. Assumendo che \mintinline{c}{g}, \mintinline{c}{h}, \mintinline{c}{i} e \mintinline{c}{j} vengano mappate rispettivamente in \register{r0}, \register{r1}, \register{r2} e \register{r3} e che il risultato vada in \register{r0}, otteniamo:
\begin{minted}[linenos]{arm}
cmp r2, r3   ; setta i flag
addeq r0, r0, r1   ; se i == j, salva in r0 g + h
subne r0, r0, r1   ; altrimenti, salva in r0 g - h
\end{minted}

\subsection*{Condizioni di disuguaglianza}
Vediamo ora invece una condizione di disuguaglianza:
\begin{minted}[linenos, breaklines, tabsize = 4]{c}
if (i < j){
	f = g + h;
} else {
	f = g - h;
}
\end{minted}
\subsubsection{Implementazione MIPS}
Assumendo che le variabili vengano mappate come sopra, il codice MIPS non appare troppo diverso, se non per l'utilizzo dell'istruzione \mintinline{asm}{slt}:
\begin{minted}[linenos, tabsize = 4]{asm}
  slt $a2, $a2, $a3   # setta $a2 se i < j
  beq $a2, $zero, L2   # se $a2 == 0 (non settato), vai a L2
  add $v0, $a0, $a1
  j L3   # salta a L3
L2:
  sub $v0, $a0, $a1
L3:
\end{minted}
\subsubsection{Implementazione x86}
L'implementazione è quasi identitica a quella della condizione di uguaglianza, cambia solamente l'istruzione di salto.
\begin{minted}[linenos, tabsize = 4]{gas}
  cmpq %rcx, %rdx  # confronta i e j e setta il flag
  jge L2   # se i < j, salta a L2
  leaq (%rdi, %rsi), %rax  # salva in %rax g + h
  jmp L3
L2:
  movq %rdi, %rax  # sposta g da %rdi a %rax
  subq %rsi, %rax  # salva in %rax
L3:
\end{minted}
Anche l'implementazione con \mintinline{gas}{cmov} è simile:
\begin{minted}[linenos, tabsize = 4]{gas}
leaq (%rdi, %rsi), %rax  # salva in %rax g + h
subq %rsi, %rax  # salva in %rax
cmpq %rcx, %rdx  # flag
cmovge %rdi, %rax  # sposta %rdi in %rax se il i < j
\end{minted}

\subsubsection{Implementazione ARM}
Ancora una volta, le indicazioni condizionali delle istruzioni ARM ci semplificano la vita:
\begin{minted}[linenos]{arm}
cmp r2, r3   ; setta i flag
addlt r0, r0, r1   ; se i < j, salva in r0 g + h
subge r0, r0, r1   ; altrimenti, salva in r0 g - h
\end{minted}

\section{Cicli}
Ora analizziamo l'implementazione di un ciclo con condizione di terminazione basata sui valori contenuti in un array di interi. Vedremo che l'implementazione usata sarà sempre quella del salto condizionale, nonostante ARM coi suoi suffissi potrebbe prestarsi ad implementazioni alternative. Il codice C è il seguente:
\begin{minted}[linenos, breaklines, tabsize = 4]{c}
int i = 0;
while (a[i] == k){
	i += 1;
}
\end{minted}

\subsubsection{Implementazione MIPS}
In MIPS mappiamo \mintinline{c}{k} in \register{\$a0}, l'indirizzo di \mintinline{c}{a} in\register{\$a1} e \mintinline{c}{i} in \register{\$v0}. Notiamo che per poter operare il confronto \mintinline{c}{a[i]==k} sarà necessario servirsi di un registro temporaneo (\register{\$t0}) di appoggio doe caricare l'elemento del vettore \mintinline{c}{a}; inoltre, poiché lemodalità d'indirizzamento di MIPS sono molto poco potenti, sarà necessario operare lo shift logico a sinistra a ogni ciclo per mantenere la regolarità delle words.
\begin{minted}[linenos, tabsize = 4]{asm}
start:
	move $v0, $zero	 # i = 0
L1:
	sll $t1, $v0, 2	 # salva in $t1 4 * i
	add $t1, $t1, $a1	 # ottieni l'indirizzo di a[i]
	lw $t0, 0($t1)	 # carica in $t0 il contenuto di a[i]
	bne $t0, $a0, L2	 # salta a l2 se a[i] è diverso da k
	addi $v0, $v0, 1
	j L1
L2:
\end{minted}

L'implementazione di \mintinline{batch}{gcc} è leggermente più complessa e aggira la scarsa potenza sull; indirizzamento di MIPS usando non uno, ma due registri come contatori: \register{\$v0}, contiene \mintinline{c}{i} e \register{\$a1}, che contiene l'elemento successivo dell'array; quest'ultimo registro inoltre viene sempre incrementato di 4, dal momento che ogni elemento dell'array, in quanto \mintinline{c}{int}, è grande 4 byte.
\begin{minted}[linenos, tabsize = 4]{asm}
start:
	lw $a2, 0($a1)
	bne $a2, $a0, L2
	add $a1, $a1, 4
	move $v0, $zero
L1:
	addi $a1, $a1, 4
	lw $v1, -4($a1)
	addi $v0, $v0, 1
	beq $v1, $a0, L1
	j L3
L2:
	move $v0, $zero
L3:
\end{minted}

\subsubsection{Implementazione x86}
\begin{minted}[linenos, tabsize = 4]{gas}
start:
	cmpl (%rsi), %edi
	jne L2
	movq $0, %rax
L1:
	addq $1, %rax
	cmpl %edi, (%rsi, %rax, 4)
	je L1
	jmp L3
L2:
	movq $0, %rax
L3:
\end{minted}

\subsubsection{Implementazione ARM}
Assumiamo che le variabili siano mappate in questo modo: \mintinline{c}{k} in \register{r1}, l'indirizzo di \mintinline{c}{a} in\register{r0} e \mintinline{c}{i} in \register{\$v0}
\begin{minted}[linenos,tabsize = 4]{arm}
start:
	ldr r3, [r1]
	cmp r0, r3
	bne L2
	mov r3, #0
L1:
	add r3, r3, #1
	ldr r2 [r1, #4]!
	cmp r2, r0
	beq L1
	b L3
L2:
	mov r3, #0
L3:
	mov r0, r3
\end{minted}

\section{Invocazione di subroutine}
\subsection*{Funzioni foglia}

\begin{minted}[linenos,tabsize = 4]{c}
int esempio_foglia(int g, int h, int i, int j){
	int f;
	f = (g + h) - (i + j);
	return f;
}
\end{minted}

\subsubsection{Implementazione MIPS}
\begin{minted}[linenos,tabsize = 4]{asm}
esempio_foglia:
	addu $a0, $a0, $a1
	addu $v0, $a2, $a3
	subu $v0, $a0, $v0
	jr $ra
\end{minted}

\subsubsection{Implementazione x86}
\begin{minted}[linenos,tabsize = 4]{gas}
esempio_foglia:
	leal (%rdi, %rsi), %eax
	addl %ecx, %edx
	subl %edx, %eax
	ret
\end{minted}

\subsubsection{Implementazione ARM}
\begin{minted}[linenos,tabsize = 4]{arm}
esempio_foglia:
	add r0, r0, r1
	add r3, r2, r3
	rsb r0, r3, r0
	bx lr
\end{minted}

\subsection*{Funzioni non foglia}

\begin{minted}[linenos,breaklines, tabsize = 4]{c}
int inc(int n){
	return n + 1;
}

int f(int x){
	return inc(x) - 4;
}
\end{minted}

\subsubsection{Implementazione MIPS}
\begin{minted}[linenos, breaklines, tabsize = 4]{asm}
inc:
	addiu $v0, $a0, 1
	jr $ra

f:
	addiu $sp, $sp, -4
	sw $ra, 0($sp)
	jal inc
	addiu $v0, $v0, -4
	lw $ra, 0($sp)
	addiu $sp, $sp, 4
	jr $ra
\end{minted}

Implementazione \mintinline{batch}{gcc}:
\begin{minted}[linenos, breaklines, tabsize = 4]{asm}
inc:
	addiu $v0, $a0, 1
	jr $ra

f:
	addiu $sp, $sp, -8
	sw $ra, 4($sp)
	jal inc
	addiu $v0, $v0, -4
	lw $ra, 4($sp)
	addiu $sp, $sp, 8
	jr $ra
\end{minted}

\subsubsection{Implementazione x86}
\begin{minted}[linenos, breaklines, tabsize = 4]{gas}
inc:
	leal 1(%rdi), %eax
	ret

f:
	call inc
	subl $4, %eax
	ret
\end{minted}

\subsubsection{Implementazione ARM}
\begin{minted}[linenos, breaklines, tabsize = 4]{arm}
inc:
	add r0, r0, 31
	bx lr

f:
	str lr, [sp, #-4]!
	bl inc
	sub r0, r0 #4
	ldr pc, [sp], #4
\end{minted}

Implementazione \mintinline{batch}{gcc}:
\begin{minted}[linenos, breaklines, tabsize = 4]{arm}
inc:
	add r0, r0, #1
	bx lr

f:
	stmfd sp!, {r4, lr}
	bl inc
	sub r0, r0 #4
	ldmfd sp!, {r4, pc}
\end{minted}

\section{Copia stringa}
Consideriamo ora una funziona che copia un array di caratteri:
\begin{minted}[linenos, breaklines, tabsize = 4]{c}
void copia_stringa(char *d , const char *s){
	int i = 0;

	while((d[i] = s[i]) != 0){
		i+=1;
	}
}
\end{minted}

\subsubsection{Implementazione MIPS}
Abbiamo già discusso l'implementazione MIPS di questa funzione in~\ref{sec:mipstring}, per cui qui riporteremo solamente il codice, generato da \mintinline{batch}{gcc}:
\begin{minted}[linenos, breaklines, tabsize = 4]{asm}
copia_stringa:
	lb $v0, 0($a1)
	sb $v0, 0($a0)
	beq $v0, $zero, L5
	move $v0, $zero
L3:
	addiu $v0, $v0, 1
	addu $v1, $a1, $v0
	lb $v1, 0($v1)
	addu $a2, $a0, $v0
	sb $v1, 0($a2)
	bne $v1, $zero, L3
L5:
	jr $ra
\end{minted}

\subsubsection{Implementazione x86}

\begin{minted}[linenos, breaklines, tabsize = 4]{gas}
copia_stringa:
	movzbl (%rsi), %eax
	movb %al, (%rdi)
	testb %al, %al
	je L1
	movl $0, %eax
L3 :
	addl $1, %eax
	movslq %eax, %rcx
	movzbl (%rsi, %rcx), %edx
	movb %dl, (%rdi, %rcx)
	testb %dl, %dl
	jne L3
L1:
	ret
\end{minted}

\subsubsection{Implementazione ARM}

\begin{minted}[linenos, breaklines, tabsize = 4]{arm}
copia_stringa:
	ldrb r3, [r1]
	strb r3, [r0]
	cmp r3, #0
	bxeq lr
L3:
	ldrb r3, [r1, #1]!
	strb r3, [r0, #1]!
	cmp r3, #0
	bne L3
	bx lr
\end{minted}


\end{document}
