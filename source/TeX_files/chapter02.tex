\chapter{Aritmetica dei calcolatori}

\section{Informazione nei computer}

\subsection{I transistor}
\begin{wrapfigure}{r}{0.4\textwidth}
	\includegraphics[width=0.9\linewidth]{images/transistor.png}
	\label{fig:transistor}
	\centering
\end{wrapfigure}
Tutti i computer moderni sono composti da \textit{transistor} (detti anche triodi) che sono strutture bistabili, ovvero che possono assumere due stati come un interruttore: 0=spento e 1=acceso. Molti \textit{transistor} collegati tra loro in una sorta di matrice possono rappresentare delle serie di porte logiche, ed è questa la struttura che sta alla base dell'architettura dei moderni calcolatori.\\ 
Un computer memorizza (e manipola) solo sequenze di 0 e 1 (sequenze di bit); anche l’ENIAC funzionava allo stesso modo, solo che al posto dei \textit{transistor} era composto da \textit{valvole termoioniche}, che in ultima analisi non erano differenti nel funzionamento (assumono sempre i due stati descritti in precedenza, solo più lentamente).
\subsection{Interpretazione delle informazioni} In seguito le sequenze di bit che i computer elaborano/memorizzano possono essere interpretate in tantissimi modi diversi, tra cui numeri, caratteri, suoni, immagini, istruzioni e molti altri.\\
Alla base di tutte le interpretazioni che si possono dare alle stringhe di simboli (che nel caso del computer sono proprio i due stati del bit) sta il concetto di \textbf{codifica}. La \textbf{codifica} è appunto uno schema, una legge, un \textit{mapping} che permette di tradurre prima ed interpretare poi stringhe di simboli.
Nell’ambito dell’IT le codifiche sono fortemente caratterizzate dalla lunghezza (dal numero di bit) delle “parole” elementari della codifica. Ad esempio per rappresentare tutti i caratteri (tabella ASCII) utilizziamo  8 bit [256 caratteri].
Si osservi che essendo i \textit{transistor} sistemi bistabili la base 2 (con cifre 0 e 1) è perfetta per rappresentare la codifica dei dati memorizzati/elaborati da essi.
\section{I numeri}
Limitiamoci al caso dei numeri per spiegare il concetto di \textbf{codifica}:\\
Ricordiamo che i  metodi di rappresentazione numerica che studiamo sono posizionali, ovvero il peso di ogni cifra varia in base alla posizione che essa  occupa.\\
In generale se una base è composta da B elementi essa ha B cifre (da 0 a B-1) utilizzate per scrivere ogni numero.
Questa formula ci restituisce il valore di ogni numero scritto in una qualsiasi base B:\\
\[c_{i} c_{i-1} c_{i-2}... c_{0}=c_{i}\cdot B^{i}+...+c_{0}\cdot B^{0}\]\\
dove $c_{i}$ è la cifra in posizione \textit{i}.

\subsection{Regole di conversione tra basi}
\textit{(un elenco delle principali basi è troppo mainstream?)}\\\\
Vediamo ora come operare la conversione tra le principali basi:
\begin{itemize}[noitemsep,nolistsep]
	\item \textbf{da base 2 a base 16}: partendo da destra, si dividono le cifre binarie in gruppi da 4 cifre ciascuno, e ognuno di questi corrisponderà a una cifra esadecimale; qualora il numero di cifre binarie non sia divisibile per 4, si completi con degli 0 in modo da ottenere gruppi da 4\\ (\textit{esempio: $(11011)_{2}$ diventerà $(0001\text{ }1011)_{2}$, ovvero $(1B)_{16}$});
	\item \textbf{da base 2 a base 8}: analogamente, si dividano le cifre binarie in gruppi da 3 cifre ciascuno, e ognuno di questi corrisponderà a una cifra ottale;
	\item \textbf{da una qualsiasi base $B$ a base 10}: come visto sopra, si moltiplica ogni cifra $c_{i}$ per $B^{i}$, dipendentemente dalla sua posizione;
	\item \textbf{da base 10 a una qualsiasi base B}:
	\begin{enumerate}[noitemsep,nolistsep]
		\item si consideri un numero $x_{10}$ e una base $B$;
		\item si divida $x$ per $B$;
		\item il resto della divisione è la cifra da inserire a sinistra nel numero convertito;
		\item si assegni a $x$ il quoziente della divisione;
		\item si torni al punto 2 e si ripeta finché $x\neq0$.
	\end{enumerate}
\end{itemize}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth,keepaspectratio]{images/esempi_conversioni.png}
	\caption{Alcuni esempi di conversione}
\end{figure}

\subsection{I naturali} Nella codifica binaria un numero naturale è rappresentato su \textit{k} cifre binarie, dove con \textit{k} cifre si possono rappresentare i numeri tra 0 e $2^{k}-1$.\\
La codifica più comune per gli interi spesso usa i byte, sequenze di 8 bit, che tuttavia richiedono molte cifre per rappresentare un numero e quindi spesso, per semplificare la lettura, si usa scrivere i numeri in esadecimale (quindi scrivendo un quarto delle cifre rispetto alla binaria).

\paragraph*{Somma e sottrazione}
Le operazioni somma e sottrazione funzionano allo stesso modo del sistema utilizzato nella numerazione decimale con il riporto. Si guardino gli esempi qui sotto riportati, già di per sè esplicativi del processo:\\
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth,keepaspectratio]{images/Somma-Bin.png}
	\caption{Esempio di somma}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth,keepaspectratio]{images/Sottrazione-Bin.png}
	\caption{Esempio di differenza}
\end{figure}

\paragraph*{Moltiplicazione} La moltiplicazione in base binaria si può semplificare con il metodo dello shifting, che è più facile illustrare con un esempio:  \begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth,keepaspectratio]{images/Moltiplicazione-Bin.png}
	\caption{Esempio di prodotto}
\end{figure}
Si noti che quando è presente un 1 si riscrive il numero (nella posizione corrispondente) mentre  quando è presente uno 0 semplicemente non si scrive nulla (e si va solo avanti con le posizioni).

\subsection{Gli interi} Finora abbiamo visto come si codificano solo i numeri naturali, ma esistono metodi di codifica che permettono di rappresentare anche i numeri negativi (quindi l’insieme degli interi). Le tecniche più comuni sono: modulo e segno, complemento a 1 (\textit{CA1}) e complemento a 2 (\textit{CA2}).

\paragraph*{Codifica con Modulo e Segno:} Idea semplice: si usano $k-1$ bit per rappresentare il valore assoluto (modulo) del numero  ed un bit per codificare il segno (0=positivo, 1=negativo). In questo modo con k bit si possono codificare valori tra $-2^{k-1}+1 \text{ e} +2^{k-1}-1$.\\
\underline{N.B.}: esistono due codifiche per lo $0$, $-0$  e $+0$, e questo è un spreco.

\paragraph*{Codifica in Complemento a 1:} L’idea alla base è semplice, il primo bit indica sempre il segno e per ottenere l’opposto di un numero positivo si invertono tutti gli 0 in 1 e gli 1 in 0 (e lo stesso si fa per ottenere l’opposto di un numero negativo). Si hanno ancora due rappresentazioni per +0 e -0 (rispettivamente, utilizzando 4 bit, 0000 e 1111). È più facile da sommare rispetto al modulo e segno ma solo se il bit significativo non da riporto.
Quando si sommano due numeri in \textit{CA1}:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth,keepaspectratio]{images/Somma-CA1.png}
	\caption{Esempio di somma in CA1}
\end{figure}
\begin{itemize}[noitemsep]
\item Si deve verificare che i riporti delle prime due cifre significative siano uguali, altrimenti il numero che si ottiene non è rappresentabile in CA1 su k bit.
\item Alla fine si deve sommare il riporto della prima cifra al risultato ottenuto (ultima riga).
\end{itemize}
\paragraph*{Codifica in Complemento a 2:} Per tradurre un numero da intero con segno a complemento a 2 (\textit{CA2}) basta invertire tutti i bit e poi sommare 1. Viceversa, per convertire da \textit{CA2} a binario, si sottrae 1 e poi si invertono tutti i bit. \\
Ancora una volta il bit più significativo indica il segno, ma in questo caso la codifica dello 0 è unica, quindi con \textit{k} bit si possono rappresentare i numeri da $-2^{k-1}$ a $2^{k-1}-1$. Anche la somma è più semplice ma questo lo vedremo in futuro.
\subsubsection{Somma algebrica in Complemento a 2} L'utilizzo della codifica \textit{CA2} permette di eseguire somme algebriche senza alcuna differenza operativa, ma rende necessario prestare attenzione agli \textit{overflows}.\\
Con il termine \textit{overflow} si intende la situazione in cui, date in input delle informazioni codificate in un numero $k$ di bit arbitrariamente scelto, lo stesso numero $k$ di bit non è sufficiente a codificare le informazioni in output. \\
Diamo subito un esempio: supponiamo di voler eseguire $-64-8$ utilizzando il \textit{CA2} e $k=7$ bit. Ricordiamo che:\\\\
$-64=1000000_{2}=\overline{1000000}+1=0111111+1=1000000 \text{ in \textit{CA2;}}$\\
$-8=0001000_{2}=\overline{0001000}+1=1110111+1=1111000 \text{ in \textit{CA2}}.$\\\\
A questo punto eseguiamo la somma algebrica
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth,keepaspectratio]{images/overflow.png}
	\caption{(Il numero fra parentesi indica l'ultimo riporto, che chiaramente non possiamo inserire poiché sforerebbe i 7 bit)}
\end{figure}
Osserviamo così che, per $k=7$ bit, $-64-8=0111000_{2}=56_{10}$, che ovviamente non ci piace; concludiamo quindi che la somma algebrica $-64-8=-72$ \textit{non} è rappresentabile con soli $k=7$ bit.\\

Possiamo dire che, in generale, dati due numeri $a, b$ aventi lo stesso segno, avremo probelmi di \textit{overflow} se 
\begin{itemize}[noitemsep,nolistsep]
	\item $a+b>2^{k-1}-1$
	\item $a+b<-2^{k-1}$
\end{itemize}
ricordando che $-2^{k-1}\le a,b\le 2^{k-1}-1$.

\subsubsection{Aritmetica modulare} Incosapevolmente noi utilizziamo l'\textit{aritmetica modulare} quasi continuamente, nella nostra quotidianità; l'esempio più comune è quando sommiamo le ore, che sono organizzate in modulo 24 (da cui la denominazione ufficiosa di "Matematica dell'orologio"), ma anche minuti e secondi (modulo 60) e gli angoli (modulo 360).\\
Diamone una descrizione intuitiva: fissato un numero $n$ finito di valori, arrivato al numero più grande ($n-1$), al successivo avrò che $(n-1)+1=0$.\\
Per completezza, forniamo ora la relazione di equivalenza di due numeri in modulo $n$:\\
\begin{equation*}
\centering
a\equiv b \longleftrightarrow a\%n=b\%n
\end{equation*}

Quando noi eseguiamo delle operazioni sui numeri in base 2 su $k$ bit, stiamo lavorando in un ambiente in modulo $2^{k}$, e calcolando $a+b$ stiamo in realtà trovando $(a+b)\%2^{k}$, e i due valori saranno uguali se e solo se $a+b<2^{k}$, perché altrimenti ogni valore successivo ricomincerebbe da 0: questo è l'\textit{overflow}.\\
In particolare quando lavoriamo su numeri interi in \textit{CA2} dobbiamo ricordare che, se $-2^{k-1}\le a+b\le 2^{k-1}-1$ non avremo \textit{overflow}, altrimenti
\begin{itemize}[noitemsep,nolistsep]
	\item se $a+b<2^{k-1}-1$, otterremo $a+b+2^{k}$ $\longrightarrow$ \textit{OVERFLO(W)!}
	\item se $a+b>-2^{k-1}$, otterremo $a+b-2^{k}$ $\longrightarrow$ \textit{OVERFLO(W)!}
\end{itemize}

\subsection{I Reali} Non è sempre semplice codificare un numero reale $\alpha \in \mathbb{R}$, poiché di questo insieme fanno parte i numeri cosiddetti \textit{irrazionali}, che presentano infinite cifre non periodiche dopo la virgola (si pensi ad esempio a $\pi=3,14159...$, o $e=2.71828...$, o ancora $\sqrt{2}=1.41421...$).\\
Alcuni numeri non possono quindi essere rappresentati con un numero finito di bit, per cui ne rappresenteremo solo un'approssimazione, e per farlo abbiamo sviluppato due metodi: la rappresentazione a \textbf{virgola fissa} (o \textit{fixed point}) e quella a \textbf{virgola mobile} (o \textit{floating point}).

\subsubsection{Codifica in virgola fissa} Questo sistema di cofidica prevede che, posto un numero $k$ di bit per la rappresentazione del numero, si impieghino $k-f$ bit per rappresentare la parte intera, e i restanti $f$ bit per rappresentare la parte razioneale:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth,keepaspectratio]{images/fixed_point.png}
\end{figure}
 Possiamo scrivere una formula generale più compatta. Supponiamo di voler convertire un numero $x_{10}$:
 \begin{equation*}
 x_{10}=\sum_{i=0}^{k-1} c_{i}B^{i-f}=\sum_{i=0}^{k-1} c_{i}B^{i}\cdot B^{-f}=(\sum_{i=0}^{k-1} c_{i}B^{i})\cdot B^{-f}
 \end{equation*}

\subsubsection{Codifica in virgola mobile}
Un qualsiasi numero reale può essere scritto anche nella forma $x=M*B^{E}$ dove M si dice \textit{mantissa}, E \textit{esponente} e B è la base della rappresentazione (che nel nostro caso è la leggendaria base 2).\\
Questo metodo di rappresentazione è implementato anche nell'informatica in più modi diversi ma alla base di tutti si riconosce lo stesso schema: \\
Un numero $x$ può essere rappresentato su \textit{k} bit utilizzando \textit{m} bit per il campo mantissa M ed $e=k-m$ bit per il campo esponente E; quest'ultimo permette in un certo senso di "spostare" la virgola; con esponenti negativi si avranno x "piccoli" e viceversa con esponenti positivi si avranno x "grandi".\\
Lo standard più comunemente utilizzato è l'IEEE 754 che ha questa struttura:
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\multicolumn{1}{|c|}{1 bit} & \multicolumn{1}{c|}{8 bit} & \multicolumn{1}{c|}{23 bit} \\ \hline
		Bit di segno                & Esponente                  & Mantissa                    \\ \hline
	\end{tabular}
\end{table}

Le caratteristiche della rappresentazione sono:
\begin{itemize}
	\item Limiti dell'esponente: $-2^{e-1}+1 < E \le 2^{e-1}-1$
	\item 
\end{itemize}
